---
layout: post
title: redis基本操作 备忘
date: 2020-9-8 14:32:00
categories:  java maven
---
### 1. 命令行直接操作
···shell
[www@localhost tests]$ redis-cli 
127.0.0.1:6379> set aa 111
OK
127.0.0.1:6379> exit
[www@localhost tests]$ redis-cli get aa
"111"

```

### 2. 优雅关闭redis
save 表示先生成次持久化文件
```shell
[www@localhost tests]$ redis-cli shutdown save
[www@localhost tests]$ tree .
.
|-- data
|   `-- dump6379.rdb
|-- logs
|   `-- 6379.log
|-- redis-6379.conf
`-- start.sh

2 directories, 4 files

```


### 3. 常用命令
1.  keys * 列出所有健
2. dbsize 健总数
3. exists key 是否存在某个键
4. del key 删除
5. expire key 设置key的过期时间
6. type key 返回类型


### 4.5种数据结构
string, hash, list, set, zset.
这五种是对外的数据结构，每一种数据结构内部有自己的**编码**，内部编码可以使用**object encoding key**来查看

**这种设计的好处**:
改动内部编码不影响外部编码，也是一种分层的设计思想。

 ![部署](https://raw.githubusercontent.com/QuietListener/quietlistener.github.io/master/images/redis-1.png)


#### 1.字符串
字符串的实际值可以是: **简单字符串，复杂字符串，数字(整数，浮点数)，二进制**

最大不能超过512M
##### 命令；

###### 1. set 
1. set key value [ex seconds] [px milliseconds] [nx|xx]    
2. ex 秒级过期时间
3. px 毫秒级过期时间
4. nx 表示not exist 健不存在才能设置成功，用于添加 ，redis也提供了setnx
5. xx 表示exists 健存在才能设置成功，用于更新。

```shell
127.0.0.1:6379> set b 1 ex 100  nx
OK
127.0.0.1:6379> set b 1 ex 100  nx #第二次会失败，因为已经存在了
(nil)
127.0.0.1:6379> ttl b
(integer) 87
127.0.0.1:6379> ttl b
(integer) 86
127.0.0.1:6379> 

```
###### 2. mset mget 批零操作
```shell
127.0.0.1:6379> mset a 1 b 2 c 3 
OK
127.0.0.1:6379> mget a b
1) "1"
2) "2"

```

mset 和 mget 主要是节约了网络时间。因为一次请求的网络时间可能比redis操作还多。
###### 2. 数字操作 incr decr incrby decrby incrbyfloat
如果不是数字会返回错误
```shell
127.0.0.1:6379> set num a""
OK
127.0.0.1:6379> incr num
(error) ERR value is not an integer or out of range
127.0.0.1:6379> 
127.0.0.1:6379> set num1 1
OK
127.0.0.1:6379> incr num1 
(integer) 2
127.0.0.1:6379> incr num1 
(integer) 3
127.0.0.1:6379> incrby num1 10 
(integer) 13

```

 ![部署](https://raw.githubusercontent.com/QuietListener/quietlistener.github.io/master/images/redis-string.png)

##### 内部编码
3中内部编码:
1. int 8个自己的长整型，
2. embstr 小于39个字节的字符串，
3. raw 大于39个字节的字符串

```shell
127.0.0.1:6379> set a 10000000000000000
OK
127.0.0.1:6379> object encoding a
"int"
127.0.0.1:6379> set b "hello"
OK
127.0.0.1:6379> object encoding b
"embstr"
127.0.0.1:6379> set c "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
OK
127.0.0.1:6379> object encoding c
"raw"
127.0.0.1:6379> 

```

##### 使用场景
1. 缓存
2. 共享session
3. 限速
4. 计数




#### 2.哈希
字符串的实际值可以是: **简单字符串，复杂字符串，数字(整数，浮点数)，二进制**

最大不能超过512M
##### 命令；

###### 1. hset  hget hmget hmset
```shell
127.0.0.1:6379> hset user:1 name jun
(integer) 1
127.0.0.1:6379> hget user:1 name
"jun"
127.0.0.1:6379> hset user:1 name jun
(integer) 1
127.0.0.1:6379> hget user:1 name
"jun"
127.0.0.1:6379> hmset user:2 name andy age 20 #批量操作
OK
127.0.0.1:6379> hmget user:2 name age
1) "andy"
2) "20"
127.0.0.1:6379> 
127.0.0.1:6379> hlen user:2  #长度
(integer) 2
127.0.0.1:6379> 
127.0.0.1:6379> hexists user:2 name #是否存在某个key
(integer) 1
127.0.0.1:6379> hexists user:2 job
(integer) 0
127.0.0.1:6379> hkeys user:2 #获取所有key
1) "name"
2) "age"
127.0.0.1:6379> hvals user:2 #获取所有value
1) "andy"
2) "20"
127.0.0.1:6379> hgetall user:2 #获取所有key value
1) "name"
2) "andy"
3) "age"
4) "20"
```


##### 内部编码
1. ziplist(压缩列表)
压缩表使用紧凑的结构实现多个元素的连续存储，节约内存，但是读写效率低。
当hash类型的元素个数小于hash-max-ziplist-entries(默认512个)，并且所有值都小于hash-max-ziplist-value个字节(默认64)时候使用ziplist。

2. hashtable
读写效率高,时间复杂度为O(1)，不满足上面的要求用hashtable

```shell
127.0.0.1:6379> hmset user:1 name "junjun" #使用ziplist 
OK
127.0.0.1:6379> object encoding user:1
"ziplist"
127.0.0.1:6379> hmset user:1 description "junjunnbjunjunjunjunaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" #某个值大于64了使用hashtable
OK
127.0.0.1:6379> object encoding user:1
"hashtable"
127.0.0.1:6379> 
```






#### 3.列表(List)
用来存储多个**有序**的字符串

 ![部署](https://raw.githubusercontent.com/QuietListener/quietlistener.github.io/master/images/redis-list.png)

##### 1. 命令
```shell
127.0.0.1:6379> rpush l1 a b c #从右边一次插入 现在list= [a b c]
(integer) 3
127.0.0.1:6379> lrange l1 0 -1 #从左边开始列出元素 
1) "a"
2) "b"
3) "c"
127.0.0.1:6379> lpush l1 a1 #左边插入一个元素list = [a1 a b c ]
(integer) 4
127.0.0.1:6379> lrange l1 0 -1 #从左边开始列出元素
1) "a1"
2) "a"
3) "b"
4) "c"
127.0.0.1:6379> lrange l1 0 2 #从左边列出 0 1 2 元素
1) "a1"
2) "a"
3) "b"
127.0.0.1:6379> lindex l1 1 #列出下表为 idx的数据
"a"
127.0.0.1:6379> lindex l1 -1 #列出从左到右最后一个元素
"c"
127.0.0.1:6379> lpop l1 #删除左边第一个 list = 【a b c】
"a1"
127.0.0.1:6379> rpop l1 #删除右边第一个 list = [a b ]
"c"
127.0.0.1:6379> lrange l1 0 -1 
1) "a"
2) "b"
127.0.0.1:6379> rpush l1 c1 c1 c1 c1 d1 d1 
(integer) 8
127.0.0.1:6379> lrange l1 0 -1
1) "a"
2) "b"
3) "c1"
4) "c1"
5) "c1"
6) "c1"
7) "d1"
8) "d1"
127.0.0.1:6379> lrem l1 2 c1 #2 > 0  从左往右删除最多2个c1 list = [a b c1 c1 d1 d1 ]
(integer) 2
127.0.0.1:6379> lrem l1 -1 d1 #-1<0 从右往左删除最多一个d1 list = [a b c1 c1 d1 ] 
(integer) 1
127.0.0.1:6379> lrange l1 0 -1
1) "a"
2) "b"
3) "c1"
4) "c1"
5) "d1"

127.0.0.1:6379> lset l1 1 b1 # 下标为1的设置为b1  list = [a b1 c1 c1 d1 ] 
OK
127.0.0.1:6379> lrange l1 0 -1 
1) "a"
2) "b1"
3) "c1"
4) "c1"
5) "d1"
127.0.0.1:6379> ltrim l1 1 3 # 保留下表1到3的元素  list = [b1 c1 c1]
OK
127.0.0.1:6379> lrange l1 0 -1
1) "b1"
2) "c1"
3) "c1"
127.0.0.1:6379> 

```

##### 内部编码
1. ziplist(压缩列表)
压缩表使用紧凑的结构实现多个元素的连续存储，节约内存，但是读写效率低。
当hash类型的元素个数小于list-max-ziplist-entries(默认512个)，并且所有值都小于list-max-ziplist-value个字节(默认64)时候使用ziplist。

2. linkedlist(链表)
读写效率高,时间复杂度为O(1)，不满足上面的要求用hashtable

```shell
127.0.0.1:6379> lrange l1 0 -1
1) "b1"
2) "c1"
3) "c1"
127.0.0.1:6379> rpush l1 "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
(integer) 4
127.0.0.1:6379> object encoding l1
"linkedlist"

```

##### 使用场景
1. lpush+lpop 栈
2. lpush+rpop 队列 fifo
3. lpush+ltrim 有限集合
4. lpush+brpop 消息队列



#### 4.集合(set)
集合不允许有相同元素，集合是无序的
redis支持集合的增删改查，和集合的交集，并集，差集等操作

##### 命令；
1. 集合内操作
```shell
127.0.0.1:6379> sadd s1 a b c c  
(integer) 3
127.0.0.1:6379> scard s1 #元素个数
(integer) 3
127.0.0.1:6379> sismember s1 c #判断c是否在集合中
(integer) 1
127.0.0.1:6379> sismember s1 d #判断d是否在集合中
(integer) 0
127.0.0.1:6379> srandmember s1 2 #随机返回2个元素 但是不删除
1) "b"
2) "a"
127.0.0.1:6379> srandmember s1 2
1) "c"
2) "a"
127.0.0.1:6379> spop s1 #随机弹出一个元素，并删除
"a"
127.0.0.1:6379> smembers s1 #列出所有元素
1) "c"
2) "b"

```

2. 集合间操作
```shell
127.0.0.1:6379> sadd user1 music football drinking
(integer) 3
127.0.0.1:6379> sadd user2 football drinking swimming
(integer) 3
127.0.0.1:6379> sadd user3 football swimming singing
(integer) 3
127.0.0.1:6379> sinter user1 user2 user3 #交集
1) "football"
127.0.0.1:6379> sunion user1 user2 user3  #并集
1) "singing"
2) "drinking"
3) "swimming"
4) "football"
5) "music"
127.0.0.1:6379> sdiff user1 user2 #差集
1) "music"
127.0.0.1:6379> sdiffstore user12diff  user1 user2 #如果要把结果存到另一个set在原来命令后面加一个store 并指定名字即可
(integer) 1
127.0.0.1:6379> smembers user12diff
1) "music"

```


##### 集合内部编码
1. intset(整数集合)
集合中都是整数，并且个数小与set-max-intset-entries（默认512个），这样减少内存使用。

2. hashtable(链表)

无法满足intset时候会用hashtable。
```shell

127.0.0.1:6379> sadd s2 1 2 3 4 #全部是整数并且小于512个
(integer) 4
127.0.0.1:6379> object encoding s2
"intset"
127.0.0.1:6379> sadd s3 a b c #不是整数元素了
(integer) 3
127.0.0.1:6379> object encoding s3
"hashtable"
127.0.0.1:6379>
```
##### 集合使用场景
1. 标签 sadd
2. 生成随机数 spop srandmember
3. sadd sinter 社交上的共同需求




#### 4.有序集合(zset)
每一个结婚元素有一个分数，根据分数来排序。

##### 命令；
```shell
127.0.0.1:6379> zadd z1 1 a #添加元素 
(integer) 1
127.0.0.1:6379> zadd z1 2 b 3 c 4 d #批量添加 数字是分数
(integer) 3
127.0.0.1:6379> zcard z1 #个数
(integer) 4
127.0.0.1:6379> zscore z1 b #某个元素的分数
"2"
127.0.0.1:6379> zrank z1 b #按分数从小到大，b排第2位
(integer) 1
127.0.0.1:6379> zrank z1 a ##按分数从小到大，a排第1位
(integer) 0
127.0.0.1:6379> zrevrank z1 a #按分数从大到小，a排第4位
(integer) 3
127.0.0.1:6379> zrem z1 d #删除d
(integer) 1
127.0.0.1:6379> zincrby z1  10 a #a的分数加10
"11"
127.0.0.1:6379> zrank z1 a  
(integer) 2
127.0.0.1:6379> zrange z1 0 10 withscores #分数从小到大 找出排序为0到10的元素
1) "b"
2) "2"
3) "c"
4) "3"
5) "a"
6) "11"
127.0.0.1:6379> zrevrange z1 0 10 withscores #分数从大到小 找出排序为0到10的元素
1) "a"
2) "11"
3) "c"
4) "3"
5) "b"
6) "2"
127.0.0.1:6379> zrangebyscore z1 3 10 withscores #分数小到大 找出分数为3到10的所有元素
1) "c"
2) "3"
127.0.0.1:6379> zrangebyscore z1 3 20  withscores  #分数小到大 找出分数为3到20的所有元素
1) "c"
2) "3"
3) "a"
4) "11"
127.0.0.1:6379> zrevrangebyscore z1 30 3  withscores  #分数大到小 找出分数为30到3的所有元素
1) "a"
2) "11"
3) "c"
4) "3"

```



##### zsort内部编码
1. ziplist(整数集合)
元素个数小于zset-max-ziplist-entries（默认128个）并且所有元素长度都小于zet-max-ziplist-value(默认64字节)，这样减少内存使用。

2. skiplist（跳表）
读写效率高

```shell
127.0.0.1:6379> zadd z2  10 a
(integer) 1
127.0.0.1:6379> object encoding z2
"ziplist"
127.0.0.1:6379> zadd z2  10 bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
(integer) 1
127.0.0.1:6379> object encoding z2
"skiplist"
127.0.0.1:6379> 

```


### redis单线程架构
1. 使用io多路复用
2. 命令会进入一个队列然后依次执行
3. 单线程不会有并发问题

#### 为什么快?
1. 内存操作
2. 单线程，没有上下文切换，也没有线程并发的问题
3. epoll 非阻塞io多路复用

#### 问题
某个命令执行时间过长，造成阻塞，很致命
