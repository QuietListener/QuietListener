---
layout: post
title: 领域驱动设计
date: 2022-1-27 14:32:00
categories:  领域驱动
---

>领域驱动的目标是通过关注领域模型(而不是技术)来创建更好的软件。

> 他们不断地纠正我的错误，在这个过程中我开始学习他们的知识。我们共同消除了术语上的不一致和歧义，也消除了他们在技术观点上的分歧，在这个过程中，他们也得到了学习。他们的解释更准确和一致了，然后我们开始共同开发一个模型。

+ 领域专家和开发人员一起理解业务的过程，最终生成合理的模型。

<br>

> 我觉得自己已经理解了足够多的知识，可以试着编写一些代码了。我写了一个非常简单的原型，并用一个自动测试框架来测试它。我避开了所有的基础设施。这个原型没有持久化机制，也没有用户界面（UI）。这样我就可以专注于代码的行为。只不过几天我就能够演示简单的探针仿真了。
+ 领域驱动也可以快速迭代


>用的模型很少停留在表面。随着对领域和应用程序需求的理解逐步加深，我们往往会丢弃那些最初看起来很重要的表面元素，或者切换它们的角度。这时，一些开始时不可能发现的巧妙抽象就会渐渐浮出水面，而它们恰恰切中问题的要害

>用的模型很少停留在表面。随着对领域和应用程序需求的理解逐步加深，我们往往会丢弃那些最初看起来很重要的表面元素，或者切换它们的角度。这时，一些开始时不可能发现的巧妙抽象就会渐渐浮出水面，而它们恰恰切中问题的要害

+ 抽象是在领域模型发现过程中不断发生的。


>当人们必须通过UML图表示整个模型或设计时，麻烦也随之而来。很多对象模型图在当人们必须通过UML图表示整个模型或设计时，麻烦也随之而来。很多对象模型图在某些方面过于细致，同时在某些方面又有很多遗漏。说它们过于细致是因为人们认为必须将所有要编码的对象都放到建模工具中。而细节过多的结果是**“只见树木，不见森林”。**

* 刚开始可以不用太深入，用简单的图来表示模型。


>MODEL-DRIVEN-DESIGN（模型驱动设计）不再将分析模型和程序设计分离开，而是寻求一种能够满足这两方面需求的单一模型。 
>绑定模型和程序设计是切实可行的。但是这种绑定不能够因为技术考虑而削弱分析的功能，我们也不能接受那些只反映了领域概念却舍弃了软件设计原则的拙劣设计。模型和设计的绑定需要的是在分析和程序设计阶段都能发挥良好作用的模型。如果模型对于程序的实现来说显得不太实用时，我们必须重新设计它。而如果模型无法忠实地描述领域的关键概念，也必须重新设计它。这样，建模和程序设计就结合为一个统一的迭代开发过程。

* 分析模型vs程序设计，分析模型和程序设计可能是两拨不同的人来做的，分析模型可能是产品经理，程序设计是程序员。
* 模型驱动设计 保证了模型和设计之间的一致性。


<br>
<br>

## 分离领域

> 在面向对象的程序中，常常会在业务对象中直接写入用户界面、数据库访问等支持代码。而一些业务逻辑则会被嵌入到用户界面组件和数据库脚本中。这么做是为了以最简单的方式在短期内完成开发工作

* 领域被分散到各个角落，给迭代带来很多麻烦
  
> 要想创建出能够处理复杂任务的程序，需要做到关注点分离——使设计中的每个部分都得到单独的关注。在分离的同时，也需要维持系统内部复杂的交互关系

* 做好拆分，分层。

> LAYERED-ARCHITECTURE的基本原则是层中的任何元素都仅依赖于本层的其他元素或其下层的元素。向上的通信必须通过间接的方式进行，这些将在后面讨论。
* 分层设计，本层调用本层或者下层


|名字|作用|
|----------|----|
|用户界面层|向用户展示信息或者解释用户指令，用户可以是计算机系统，也可以是人|
|应用层|定义要完成的任务，指挥领域对象来解决问题。与其他系统进行交互。应用层要尽量简单，不要包含业务规则，知识协调领域对象，分配任务，使他们相互协作。应用层但是可以有一些其他状态，比如任务进度等|
|领域层(模型层)|负责表达业务概念，业务状态信息和业务规则，领域层是业务软件的核心|
|基础设施层|为上面各层提供通用的技术能力:为应用层传递消息，为领域层提供持久化机制，为用户界面回执屏幕组件等，基础设施能通过框架来支持四个层次之间的交互|

* 分层设计的一个比较通用的架构

> 领域对象应该将重点放在如何表达领域模型上，而不需要考虑自己的显示和存储问题，也无需管理应用任务等内容。这使得模型的含义足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效地使用这些知识。
* 业务上的抽象


>最早将用户界面层与应用层和领域层相连的模式是MODELVIEWCONTROLLER（MVC，模型—视图—控制器）框架。
* 最常见的分层

> 。领域驱动设计只有应用在大型项目上才能产生最大的收益，而这也确实需要高超的技巧。不是所有的项目都是大型项目；也不是所有的项目团队都能掌握那些技巧。
* 小项目还是糙快猛好些


## 模型的分类
Entity; ValueObject; Service;
>ENTITY（实体）有特殊的建模和设计思路。它们具有生命周期，这期间它们的形式和内容可能发生根本改变，但必须保持一种内在的连续性。

>，软件系统中的大多数‚ENTITY‛并不是人，也不是其通常意义上所指的‚实体‛或‚存在‛。ENTITY可以是任何事物，只要满足两个条件即可，一是它在整个生命周期中具有连续性，二是它的区别并不是由那些对用户非常重要的属性决定的。ENTITY可以是一个人、一座城市、一辆汽车、一张彩票或一次银行交易。

* Entity 就是必须要有一个唯一标识符(可以是Id)的对象。同一个对象，在一些场景是Entity但在另一些场景就不是Entity了，看场景。

>用于描述领域的某个方面而本身没有概念标识的对象称为VALUEOBJECT（值对象）。VALUEOBJECT被实例化之后用来表示一些设计元素，对于这些设计元素，我们只关心它们是什么，而不关心它们是谁。
* ValueObject 比如 颜色，比如 数字，不关心1是哪个1 。想一想FlyWeight模式

>在某些情况下，最清楚、最实用的设计会包含一些特殊的操作，这些操作从概念上讲不属于任何对象。与其把它们强制地归于哪一类，不如顺其自然地在模型中引入一种新的元素，这就是SERVICE（服务）。有些重要的领域操作无法放到ENTITY或VALUEOBJECT中。这当中有些操作从本质上讲是一些活动或动作，而不是事物，但由于我们的建模范式是对象，因此要想办法将它们划归到对象这个范畴里。
* Service 往往是动作。

>SERVICE。应用层SERVICE和领域层SERVICE可能很难区分。
>如果设计一个SERVICE来处理资金转账相应的借方和贷方，那么这项功能将属于领域层
* 领域层的service应该包含领域语义的。
  
> 领域驱动开发中的module不仅仅是代码的划分，而且是**概念**的划分。一个人一次考虑的事情是有限的。

* 注意 module也是一堆概念的集合，概念也需要解耦

* 建模范式 如面向对象设计
  

## 管理领域对象的生命周期
> 使用AGGREGATE进行建模，并且在设计中结合使用FACTORY和REPOSITORY，这样我们就能够在模型对象的整个生命周期中，以有意义的单元、系统地操纵它们。**AGGREGATE可以划分出一个范围**，这个范围内的模型元素在生命周期各个阶段都应该维护其固定规则。FACTORY和REPOSITORY在AGGREGATE基础上进行操作，将特定生命周期转换的复杂性封装起来。
* Aggregate Factory Repositor的作用。Aggregate用来划分范围(边界)，实现范围内的高内聚，范围外的低耦合。

### Aggregate
>AGGREGATE就是一组相关对象的集合，我们把它作为数据修改的单元。每个AGGREGATE都有一个**根（root）**和一个**边界（boundary）**。边界定义了AGGREGATE的内部都有什么。根则是AGGREGATE所包含的一个特定ENTITY。对AGGREGATE而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除根以外的其他ENTITY都有本地标识，但这些标识只在AGGREGATE内部才需要加以区别，因为外部对象除了根ENTITY之外看不到其他对象。

* 什么是Aggregate （[æɡrɪɡət ] n.合计;总数;）例如 汽车和轮胎，汽车是Aggregate Root


aggregate必须满足一些规则，aggretage内部需要满足数据一致性(就是aggregate成员之间的内部关系)
1. 根Entity必须有全局标识，并维护aggretage内部数据一致性(固定规则)
2. 边界内的Entity至少需要有本地标识，这些标识只有在Aggregate内部唯一
3. 外部对象不能引用除了根Entity以外的内部对象。根Entity可以把内部Entity的引用传递给她们，但是只能临时使用，不能保持引用。
4. 只有Aggregate的根才能通过数据库查询获取。要访问内部Entity，需要通过遍历关联来发现。
5. Aggregate内部对象可以保持对其他Aggregate根的引用。
6. 对内部Entity修改时候 Aggregate的所有固定规则都需要被满足。
   
**总的来说就是：**  
1. 我们应该将ENTITY和VALUEOBJECT分门别类地聚集到AGGREGATE中，并定义每个AGGREGATE的边界。在每个AGGREGATE中，选择一个ENTITY作为根，并通过根来控制对边界内其他对象的所有访问。只允许外部对象保持对根的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。由于根控制访问，因此不能绕过它来修改内部对象。这种设计有利于确保AGGREGATE中的对象满足所有固定规则，也可以确保在任何状态变化时AGGREGATE作为一个整体满足固定规则。
2. AGGREGATE划分出一个范围，在这个范围内，生命周期的每个阶段都必须满足一些固定规则。

**例子**
1. 采购单 采购项目 价格

### Factory
>当创建一个对象或创建整个AGGREGATE时，如果创建工作很复杂，或者暴露了过多的内部结构，则可以使用FACTORY进行封装。对象的功能主要体现在其复杂的内部配臵
>一个对象在它的生命周期中要承担大量职责。如果再让复杂对象负责自身的创建，那么职责过载将会导致问题。
>对象的创建本身可以是一个主要操作，但被创建的对象并不适合承担复杂的装配操作。将这些职责混在一起可能产生难以理解的拙劣设计。让客户直接负责创建对象又会使客户的设计陷入混乱，并且破坏被装配对象或AGGREGATE的封装，而且导致客户与被创建对象的实现之间产生过于紧密的耦合。

* 所以需要Factory, (其实核心还是将复杂性分担到不同的地方)

>FACTORY封装了创建复杂对象或AGGREGATE所需的知识。它提供了反映客户目标的接口，以及被创建对象的抽象视图.
* Factory不是领域模型中的职责，但是她任然是领域设计的一部分。

**Factory需要满足一些要求**   
1. 每个创建方法都是原子的，而且要保证被创建对象或AGGREGATE的所有固定规则。
2. FACTORY应该被抽象为所需的类型，而不是所要创建的具体类。[

**不适用Factory的情况**  
1. 类（class）是一种类型（type）。它不是任何相关层次结构的一部分，而且也没有通过接口实现多态性。
2. 构造并不复杂
3. 客户可以访问对象的所有属性，因此向客户公开的构造函数中没有嵌套的对象创建。

> FACTORY负责确保它所创建的对象或AGGREGATE满足所有固定规则，然而在把应用于一个对象的规则移到该对象外部之前应三思。FACTORY可以将固定规则的检查工作委派给被创建对象，而且这通常是最佳选择。
* factory最好还是不要自己来检查是否满足规则


### Repository
>REPOSITORY将某种类型的所有对象表示为一个概念集合（通常是模拟的）。它的行为类似于集合（collection），只是具有更复杂的查询功能。在添加或删除相应类型的对象时，REPOSITORY的后台机制负责将对象添加到数据库中，或从数据库中删除对象。这个定义将一组紧密相关的职责集中在一起，这些职责提供了对AGGREGATE根的整个生命周期的全程访问。

* 将对象的检索，持久化等操作做了封装。

>从领域驱动设计的角度来看，FACTORY和REPOSITORY具有完全不同的职责。FACTORY负责制造新对象，而REPOSITORY负责查找已有对象
> REPOSITORY应该让客户感觉到那些对象就好像驻留在内存中一样。对象可能必须被重建（的确，可能会创建一个新实例），但它是同一个概念对象，仍旧处于生命周期的中间。REPOSITORY也可以委托FACTORY来创建一个对象，
* factory和repository的区别