---
layout: post
title: 领域驱动设计
date: 2022-1-27 14:32:00
categories:  领域驱动
---

>领域驱动的目标是通过关注领域模型(而不是技术)来创建更好的软件。

> 他们不断地纠正我的错误，在这个过程中我开始学习他们的知识。我们共同消除了术语上的不一致和歧义，也消除了他们在技术观点上的分歧，在这个过程中，他们也得到了学习。他们的解释更准确和一致了，然后我们开始共同开发一个模型。

+ 领域专家和开发人员一起理解业务的过程，最终生成合理的模型。

<br>

> 我觉得自己已经理解了足够多的知识，可以试着编写一些代码了。我写了一个非常简单的原型，并用一个自动测试框架来测试它。我避开了所有的基础设施。这个原型没有持久化机制，也没有用户界面（UI）。这样我就可以专注于代码的行为。只不过几天我就能够演示简单的探针仿真了。
+ 领域驱动也可以快速迭代


>用的模型很少停留在表面。随着对领域和应用程序需求的理解逐步加深，我们往往会丢弃那些最初看起来很重要的表面元素，或者切换它们的角度。这时，一些开始时不可能发现的巧妙抽象就会渐渐浮出水面，而它们恰恰切中问题的要害

>用的模型很少停留在表面。随着对领域和应用程序需求的理解逐步加深，我们往往会丢弃那些最初看起来很重要的表面元素，或者切换它们的角度。这时，一些开始时不可能发现的巧妙抽象就会渐渐浮出水面，而它们恰恰切中问题的要害

+ 抽象是在领域模型发现过程中不断发生的。


>当人们必须通过UML图表示整个模型或设计时，麻烦也随之而来。很多对象模型图在当人们必须通过UML图表示整个模型或设计时，麻烦也随之而来。很多对象模型图在某些方面过于细致，同时在某些方面又有很多遗漏。说它们过于细致是因为人们认为必须将所有要编码的对象都放到建模工具中。而细节过多的结果是**“只见树木，不见森林”。**

* 刚开始可以不用太深入，用简单的图来表示模型。


>MODEL-DRIVEN-DESIGN（模型驱动设计）不再将分析模型和程序设计分离开，而是寻求一种能够满足这两方面需求的单一模型。 
>绑定模型和程序设计是切实可行的。但是这种绑定不能够因为技术考虑而削弱分析的功能，我们也不能接受那些只反映了领域概念却舍弃了软件设计原则的拙劣设计。模型和设计的绑定需要的是在分析和程序设计阶段都能发挥良好作用的模型。如果模型对于程序的实现来说显得不太实用时，我们必须重新设计它。而如果模型无法忠实地描述领域的关键概念，也必须重新设计它。这样，建模和程序设计就结合为一个统一的迭代开发过程。

* 分析模型vs程序设计，分析模型和程序设计可能是两拨不同的人来做的，分析模型可能是产品经理，程序设计是程序员。
* 模型驱动设计 保证了模型和设计之间的一致性。


<br>
<br>

## 分离领域

> 在面向对象的程序中，常常会在业务对象中直接写入用户界面、数据库访问等支持代码。而一些业务逻辑则会被嵌入到用户界面组件和数据库脚本中。这么做是为了以最简单的方式在短期内完成开发工作

* 领域被分散到各个角落，给迭代带来很多麻烦
  
> 要想创建出能够处理复杂任务的程序，需要做到关注点分离——使设计中的每个部分都得到单独的关注。在分离的同时，也需要维持系统内部复杂的交互关系

* 做好拆分，分层。

> LAYERED-ARCHITECTURE的基本原则是层中的任何元素都仅依赖于本层的其他元素或其下层的元素。向上的通信必须通过间接的方式进行，这些将在后面讨论。
* 分层设计，本层调用本层或者下层


|名字|作用|
|----------|----|
|用户界面层|向用户展示信息或者解释用户指令，用户可以是计算机系统，也可以是人|
|应用层|定义要完成的任务，指挥领域对象来解决问题。与其他系统进行交互。应用层要尽量简单，不要包含业务规则，知识协调领域对象，分配任务，使他们相互协作。应用层但是可以有一些其他状态，比如任务进度等|
|领域层(模型层)|负责表达业务概念，业务状态信息和业务规则，领域层是业务软件的核心|
|基础设施层|为上面各层提供通用的技术能力:为应用层传递消息，为领域层提供持久化机制，为用户界面回执屏幕组件等，基础设施能通过框架来支持四个层次之间的交互|

* 分层设计的一个比较通用的架构

> 领域对象应该将重点放在如何表达领域模型上，而不需要考虑自己的显示和存储问题，也无需管理应用任务等内容。这使得模型的含义足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效地使用这些知识。
* 业务上的抽象


>最早将用户界面层与应用层和领域层相连的模式是MODELVIEWCONTROLLER（MVC，模型—视图—控制器）框架。
* 最常见的分层

> 。领域驱动设计只有应用在大型项目上才能产生最大的收益，而这也确实需要高超的技巧。不是所有的项目都是大型项目；也不是所有的项目团队都能掌握那些技巧。
* 小项目还是糙快猛好些


## 模型的分类
Entity; ValueObject; Service;
>ENTITY（实体）有特殊的建模和设计思路。它们具有生命周期，这期间它们的形式和内容可能发生根本改变，但必须保持一种内在的连续性。

>，软件系统中的大多数‚ENTITY‛并不是人，也不是其通常意义上所指的‚实体‛或‚存在‛。ENTITY可以是任何事物，只要满足两个条件即可，一是它在整个生命周期中具有连续性，二是它的区别并不是由那些对用户非常重要的属性决定的。ENTITY可以是一个人、一座城市、一辆汽车、一张彩票或一次银行交易。

* Entity 就是必须要有一个唯一标识符(可以是Id)的对象。同一个对象，在一些场景是Entity但在另一些场景就不是Entity了，看场景。

>用于描述领域的某个方面而本身没有概念标识的对象称为VALUEOBJECT（值对象）。VALUEOBJECT被实例化之后用来表示一些设计元素，对于这些设计元素，我们只关心它们是什么，而不关心它们是谁。
* ValueObject 比如 颜色，比如 数字，不关心1是哪个1 。想一想FlyWeight模式

>在某些情况下，最清楚、最实用的设计会包含一些特殊的操作，这些操作从概念上讲不属于任何对象。与其把它们强制地归于哪一类，不如顺其自然地在模型中引入一种新的元素，这就是SERVICE（服务）。有些重要的领域操作无法放到ENTITY或VALUEOBJECT中。这当中有些操作从本质上讲是一些活动或动作，而不是事物，但由于我们的建模范式是对象，因此要想办法将它们划归到对象这个范畴里。
* Service 往往是动作。

>SERVICE。应用层SERVICE和领域层SERVICE可能很难区分。
>如果设计一个SERVICE来处理资金转账相应的借方和贷方，那么这项功能将属于领域层
* 领域层的service应该包含领域语义的。
  
> 领域驱动开发中的module不仅仅是代码的划分，而且是**概念**的划分。一个人一次考虑的事情是有限的。
*注意 module也是一堆概念的集合，概念也需要解耦。